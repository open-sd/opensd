'\" t
.\"     Title: opensdd
.\"    Author: seek
.\" Generator: Asciidoctor 2.0.18
.\"      Date: 2022-11-19
.\"    Manual: opensdd
.\"    Source: opensdd
.\"  Language: English
.\"
.TH "OPENSDD" "1" "2022-11-19" "opensdd" "opensdd"
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.ss \n[.ss] 0
.nh
.ad l
.de URL
\fI\\$2\fP <\\$1>\\$3
..
.als MTO URL
.if \n[.g] \{\
.  mso www.tmac
.  am URL
.    ad l
.  .
.  am MTO
.    ad l
.  .
.  LINKSTYLE blue R < >
.\}
.SH "NAME"
opensdd \- A highly\-configurable open\-source userspace driver daemon for Valve\*(Aqs Steam Deck.
.SH "SYNOPSIS"
.sp
opensdd [options]
.SH "DESCRIPTION"
.sp
OpenSD is a highly\-configurable userspace driver for the Steam Deck written in modern C++.  It aims to be lighweight, very fast and provide a way to fully utilize the hardware without running any closed\-source, proprietary or anti\-privacy software like Steam.
.sp
At the time of writing, there is no way to utilize the gamepad portion (buttons, thumbsticks, gyros, etc.) of the Steam Deck without also having to run Steam, since Steam implements an unpublished, undocumented, closed\-source userspace driver to make it all work.  This means signing into an online service to access basic hardware functionality on a device that you own.
.sp
This goal of this software is to provide a better, fully open\-source implementation; ultimately unlocking the hardware to be used freely and unencumbered any by proprietary requirements.
.SH "OPTIONS"
.sp
\fB\-h    \-\-help\fP
.RS 4
Display help screen.
.RE
.sp
\fB\-v    \-\-version\fP
.RS 4
Output version number and exit.
.RE
.sp
\fB\-l    \-\-log\-level <log level>\fP
.RS 4
Set minumum logging level. Valid options are: \fBverbose\fP, \fBdebug\fP, \fBinfo\fP, \fBwarn\fP, \fBerror\fP.  (Default: \fBwarn\fP)
.RE
.SH "FILES"
.sp
$XDG_CONFIG_HOME/opensd/config.ini
.RS 4
User configuration for the OpenSD daemon.
.RE
.sp
$XDG_CONFIG_HOME/opensd/profiles/*.profile
.RS 4
User\-configurable gamepad profiles.
.RE
.SH "PROJECT HOME"
.sp
.URL "https://gitlab.com/open\-sd/opensd" "" ""
.SH "WIKI"
.sp
.URL "https://gitlab.com/open\-sd/opensd/\-/wikis/home" "" ""
.SH "AUTHOR"
.sp
seek (\c
.URL "https://gitlab.com/seek\-dev" "" ")"
.SH "CONFIGURATION"
.SS "OpenSD User Manual"
.sp
.ce
\l'\n(.lu*25u/100u\(ap'
.bp
.SS "Running OpenSD"
.sp
OpenSD is intended to be run as a user\-level service, but it can be run from a terminal like most other Linux programs.  This can be useful for troubleshooting or debugging purposes since every message is logged to stdout.
.sp
OpenSD requires access to the \fBuinput\fP and \fBhidraw\fP subsystems.  To enable this access, OpenSD provides a \fBudev rule\fP which will be installed when installing OpenSD.  In this rule, access is allowed to both subsystem for members of the \fBopensd\fP group, which is also created on install.  Any user that intends to run OpenSD must be a member of this group, or otherwise have R/W access to these device nodes.  After installing for the first time it will be necessary to log out in order for the user\(cqs group changes to take effect.
.sp
For more information see the [troubleshooting] section.
.if n .sp
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
.B Warning
.ps -1
.br
.sp
Do NOT run the OpenSD daemon as root, either directly or as a system service.
.sp .5v
.RE
.sp
.ce
\l'\n(.lu*25u/100u\(ap'
.SS "From a terminal"
.sp
.if n .RS 4
.nf
.fam C
$ opensdd
.fam
.fi
.if n .RE
.sp
Will start an instance of the daemon and log all output to the terminal.  The default log level is \f(CRWARN\fP.
.sp
Or to see debug messages run:
.sp
.if n .RS 4
.nf
.fam C
$ opensdd \-l debug
.fam
.fi
.if n .RE
.sp
A full list of command line options can be shown using:
.sp
.if n .RS 4
.nf
.fam C
$ opensdd \-\-help
.fam
.fi
.if n .RE
.sp
.ce
\l'\n(.lu*25u/100u\(ap'
.SS "As a User\-Level Service"
.sp
For \fBsystemd\fP users, a service file is provided which can be run as a user\-level service that will automatically start on log\-in.
.sp
To run the OpenSD daemon as a service on user log\-in:
.sp
.if n .RS 4
.nf
.fam C
$ systemctl \-\-user enable opensd
$ systemctl \-\-user start opensd
.fam
.fi
.if n .RE
.sp
.ce
\l'\n(.lu*25u/100u\(ap'
.bp
.SS "Configuration Files"
.sp
OpenSD uses two types of configuration files.  The first type being the Daemon Configuration file (config.ini), and the second type are gamepad Profile Configuration Files (*.profile) which are loaded by the daemon.
.sp
All files use an \c
.URL "https://en.wikipedia.org/wiki/INI_file" "\fIini\-style\fP" ""
format and are easily created or modified with any text editor.
.sp
Since OpenSD is a \fIuserspace\fP daemon, configuration files are stored in \f(CR$XDG_CONFIG_HOME/opensd/\fP which, on most systems, will be \f(CR~/.config/opensd/\fP.  Gamepad profiles are stored in the \f(CRprofile\fP subdirectory, (example: \f(CR~/.config/opensd/profiles/\fP).  \fBIf the OpenSD user config directory does not exist, a new one will be created and populated with the default configuration files when the daemon is run.\fP
.if n .sp
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
.B Note
.ps -1
.br
.sp
OpenSD follows the XDG specification, so environments which set / change \f(CR$XDG_HOME\fP or \f(CR$XDG_CONFIG_HOME\fP should behave correctly.  For the purposes of this documentation we\(cqll refer to the \fBdefault\fP XDG paths for user configuration files (example: \f(CR~/.config/opensd/\fP).
.sp .5v
.RE
.sp
Basic format rules
.RS 4
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
Parsing is line\-based and space delimited.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
The files are broken into braced enclosed \fBsections\fP and \fBkeys\fP.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
Names of sections and keys are not \fBcase\-sensitive\fP, but \fIvalues\fP can be, such as file names.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
Sections are enclosed in square brackets  (example: \f(CR[SectionName]\fP)
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
Keys must be contained within a section.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
Key assignment \fBmust\fP be separated by whitespace.  (example: \f(CRkey = value1 value2 value3\fP)
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
Comments are preceeded by a \f(CR#\fP or \f(CR;\fP at the beginning of the line.
.RE
.RE
.sp
.ce
\l'\n(.lu*25u/100u\(ap'
.bp
.SS "Daemon Configuration file (config.ini)"
.sp
This single file contains a small group of options that pertain to the daemon itself.  The default configuration file for the daemon can be found at \f(CR~/.config/opensd/config.ini\fP.  An unmodified copy of this file will be installed to \f(CR/usr/local/share/opensd/config/config.ini\fP or \f(CR/usr/share/opensd/config/config.ini\fP.
.sp
An Example config.ini can be found in this documentation if you want to see what a complete file might look like.
.sp
.ce
\l'\n(.lu*25u/100u\(ap'
.bp
.SS "[Daemon] Section"
.if n .sp
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
.B Note
.ps -1
.br
.sp
This section is required.
.sp .5v
.RE
.SS "Profile"
.sp
This tells the daemon which profile to load when it starts up.  Profiles are \fBonly\fP loaded from the \f(CR~./config/opensd/profiles/\fP directory, so only specify the filename here.  OpenSD also has other methods for loading profiles once the daemon is running, this setting is only for the default profile you wish to use.
.sp
Format:
.sp
.if n .RS 4
.nf
.fam C
Profile = <filename>
.fam
.fi
.if n .RE
.sp
Example:
.sp
.if n .RS 4
.nf
.fam C
[Daemon]
Profile = default.profile
.fam
.fi
.if n .RE
.sp
.ce
\l'\n(.lu*25u/100u\(ap'
.SS "AllowClients"
.if n .sp
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
.B Note
.ps -1
.br
.sp
This feature is not yet fully implemented.
.sp .5v
.RE
.sp
This setting enables or disables the use of the CLI and GUI utilities which connect to the daemon.  If set to false, the daemon will not listen for clients.  This can be useful if you want to "lock down" a configuration so it cannot be changed while it is running.  The default is \f(CRtrue\fP.
.sp
Format:
.sp
.if n .RS 4
.nf
.fam C
AllowClients = <true | false>
.fam
.fi
.if n .RE
.sp
Example:
.sp
.if n .RS 4
.nf
.fam C
[Daemon]
AllowClients = true
.fam
.fi
.if n .RE
.sp
.ce
\l'\n(.lu*25u/100u\(ap'
.bp
.SS "Profile Configuration Files (*.profile)"
.sp
These files are used to configure the gamepad driver features and bindings.  A default profile is configured in the Daemon Configuration file (config.ini) to be loaded at startup, but you can also switch between them at any time while the daemon is running using any of several possible methods.
.sp
Gamepad profiles can be found in \f(CR~/.config/opensd/profiles/\fP.  The file extension is \f(CR*.profile\fP.
.sp
An Example Profile can be found in this documentation if you want to see what a complete file might look like.
.sp
A default profile (cleverly named \f(CRdefault.profile\fP) is provided which includes documentation in the comments on how to configure it.  It is not recommended to modify this file, instead you should make a copy of it, renaming it to \f(CRwhatever_you_want.profile\fP and edit that file instead.  If the default profile is deleted, it will be recreated when the daemon is run, so if you need a clean or \fIupdated\fP copy of the \f(CRdefault.profile\fP, simply delete it and restart the OpenSD daemon.
.sp
An unmodified copy of this file will be installed to \f(CR/usr/local/share/opensd/profiles/default.profile\fP or \f(CR/usr/share/opensd/profiles/default.profile\fP.
.sp
.ce
\l'\n(.lu*25u/100u\(ap'
.SS "[Profile] Section"
.SS "Name"
.sp
The profile name as it will appear in the GUI and through the CLI query.  Should be unique for each profile to avoid confusion.
.sp
Format:
.sp
.if n .RS 4
.nf
.fam C
Name = <Your chosen profile name>
.fam
.fi
.if n .RE
.sp
Example:
.sp
.if n .RS 4
.nf
.fam C
[Profile]
Name = My favourite gamepad profile
.fam
.fi
.if n .RE
.sp
.ce
\l'\n(.lu*25u/100u\(ap'
.bp
.SS "Description"
.sp
A breif description of the profile for use in the GUI and CLI query.  Does not affect anything else, just intended as a hint for users.
.sp
Format:
.sp
.if n .RS 4
.nf
.fam C
Description = <Description of the profile>
.fam
.fi
.if n .RE
.sp
Example:
.sp
.if n .RS 4
.nf
.fam C
[Profile]
Description = Just a profile I use for most applications.
.fam
.fi
.if n .RE
.sp
.ce
\l'\n(.lu*25u/100u\(ap'
.bp
.SS "[Features] Section"
.SS "ForceFeedback"
.sp
Enable or disables haptic / force\-feedback events for the gamepad device.  It\(cqs worth mentioning that only the \f(CRGamepad\fP device can receive force\-feedback events; the \f(CRMotion\fP or \f(CRMouse\fP devices will not receive these events.
.sp
Format:
.sp
.if n .RS 4
.nf
.fam C
ForceFeedback = <true | false>
.fam
.fi
.if n .RE
.sp
Example:
.sp
.if n .RS 4
.nf
.fam C
[Features]
ForceFeedback = true
.fam
.fi
.if n .RE
.sp
If unspecified, this value defaults to \f(CRfalse\fP.
.if n .sp
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
.B Note
.ps -1
.br
.sp
This feature is not yet fully implemented
.sp .5v
.RE
.sp
.ce
\l'\n(.lu*25u/100u\(ap'
.bp
.SS "MotionDevice"
.sp
If this is set to \f(CRtrue\fP, an additional input device will be created which will report motion control data.  Motion axes need to have thier ranges and bindings defined.  If this is disabled, any \f(CRMotion\fP device bindings will be ignored.
.sp
Format:
.sp
.if n .RS 4
.nf
.fam C
MotionDevice = <true | false>
.fam
.fi
.if n .RE
.sp
Example:
.sp
.if n .RS 4
.nf
.fam C
[Features]
MotionDevice = true
.fam
.fi
.if n .RE
.sp
If unspecified, this value defaults to \f(CRfalse\fP.
.if n .sp
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
.B Note
.ps -1
.br
.sp
While it\(cqs possible to combine gamepad and motion input into a single input device, Linux \fBkernel\fP and \fBuinput\fP specifications state that motion control devices should be separate from other gamepad / joystick input.  Not separating these can also make it difficult to configure controls in most applications.
.sp .5v
.RE
.sp
.ce
\l'\n(.lu*25u/100u\(ap'
.SS "MouseDevice"
.sp
If this is set to \f(CRtrue\fP, an additional input device will be created which will be used to send mouse / trackpad events.  Mouse events still need to have thier bindings defined.  If this is disabled, any \f(CRMouse\fP device bindings will be ignored.
.sp
Format:
.sp
.if n .RS 4
.nf
.fam C
MouseDevice = <true | false>
.fam
.fi
.if n .RE
.sp
Example:
.sp
.if n .RS 4
.nf
.fam C
[Features]
MouseDevice = true
.fam
.fi
.if n .RE
.sp
If unspecified, this value defaults to \f(CRtrue\fP.
.sp
.ce
\l'\n(.lu*25u/100u\(ap'
.bp
.SS "LizardMode"
.sp
The Steam Controller and the Steam Deck both have a kind of fallback "BIOS" mode which emulates some keyboard and mouse input using the gamepad.  Valve refers to this as "Lizard Mode".  This mode cannot be redefined.  It sends events IN ADDITION to the gamepad events created by the OpenSD driver, so it should \fBalways\fP be disabled. If you would like mouse or keyboard emulation, they should be configured with \fBbindings\fP.  When OpenSD exits, Lizard Mode is re\-enabled.
.sp
If this is set to \f(CRfalse\fP "Lizard Mode" will be disabled (\fBrecommended\fP).
.sp
Format:
.sp
.if n .RS 4
.nf
.fam C
LizardMode = <true | false>
.fam
.fi
.if n .RE
.sp
Example:
.sp
.if n .RS 4
.nf
.fam C
[Features]
LizardMode = false
.fam
.fi
.if n .RE
.sp
If unspecified, this value defaults to \f(CRfalse\fP.
.sp
.ce
\l'\n(.lu*25u/100u\(ap'
.bp
.SS "StickFiltering"
.sp
The thumbsticks on the Steam Deck have a circular range but return square\-ish data, which makes it feel odd and complicated to apply radial deadzones to. Because of this, OpenSD vectorizes the stick position and returns "cleaner", round stick ranges, as well as being able to create clean deadzone rescaling.  If you disable this setting, axis ranges are still internally normalized and rescaled to the the uinput device, but no vectorization will be applied and any \fBdeadzones will be ignored\fP.
.sp
If set to \f(CRtrue\fP thumbsticks will be filtered (\fBrecommended\fP).
.sp
Format:
.sp
.if n .RS 4
.nf
.fam C
StickFiltering  = <true | false>
.fam
.fi
.if n .RE
.sp
Example:
.sp
.if n .RS 4
.nf
.fam C
[Features]
StickFiltering  = true
.fam
.fi
.if n .RE
.sp
If unspecified this value defaults to \f(CRtrue\fP.
.if n .sp
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
.B Note
.ps -1
.br
.sp
This must be enabled for thumbstick deadzones to work.
.sp .5v
.RE
.sp
.ce
\l'\n(.lu*25u/100u\(ap'
.bp
.SS "TrackpadFiltering"
.sp
Similar to StickFiltering, but matches the square shape of the trackpad.  Filtering is only applied to absolute values.  This setting must be enabled to apply deadzones to the trackpad absolute axes.  Relative values (\f(CR*PadRelX\fP and \f(CR*PadRelY\fP) are unaffected, therefore deadzones do not affect mouse movement with the pads.
.sp
If set to \f(CRtrue\fP trackpads will be filtered (\fBrecommended\fP).
.sp
Format:
.sp
.if n .RS 4
.nf
.fam C
TrackpadFiltering  = <true | false>
.fam
.fi
.if n .RE
.sp
Example:
.sp
.if n .RS 4
.nf
.fam C
[Features]
TrackpadFiltering  = true
.fam
.fi
.if n .RE
.sp
If unspecified, this value defaults to \f(CRtrue\fP.
.if n .sp
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
.B Note
.ps -1
.br
.sp
This must be enabled for trackpad deadzones to work.
.sp .5v
.RE
.sp
.ce
\l'\n(.lu*25u/100u\(ap'
.SS "[Deadzones] Section"
.sp
These values are \fBdouble precision floating point\fP and represent the percentage of the total axis range to ignore.  A value of 0.05 would be a 5% deadzone.  Deadzones are capped at 0.9 (90%).  A value of 0 is considered disabled.  If StickFiltering is disabled, \f(CRLStick\fP and \f(CRRStick\fP deadzones will be ignored.  If TrackpadFiltering is disabled, \f(CRLPad\fP and \f(CRRPad\fP deadzones will be ignored.
.sp
Format:
.sp
.if n .RS 4
.nf
.fam C
axis      = <value>
.fam
.fi
.if n .RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRaxis\fP:  Any of the supported gamepad axes, which are: * \f(CRLStick\fP, \f(CRRStick\fP, \f(CRLPad\fP, \f(CRRPad\fP, \f(CRLTrigg\fP and \f(CRRTrigg\fP.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRvalue\fP: A double\-precision floating point value between \fB0\fP and \fB0.9\fP.
.RE
.sp
Example:
.sp
.if n .RS 4
.nf
.fam C
[Deadzones]
LStick      = 0.1
RStick      = 0.1
LPad        = 0
RPad        = 0
LTrigg      = 0
RTrigg      = 0
.fam
.fi
.if n .RE
.sp
Any undefined axis deadzone will default to \f(CR0\fP (disabled).
.if n .sp
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
.B Note
.ps -1
.br
.sp
Because the Steam Deck thumbsticks tend not to return to center completely (at least on current revisions), a small deadzone of around 0.10 (10%) is generally recommended.
.sp .5v
.RE
.sp
.ce
\l'\n(.lu*25u/100u\(ap'
.SS "[GamepadAxes] Section"
.sp
Gamepad absolute axes must have a defined range or they will not be created.  Any \f(CRGamepad\fP \f(CRABS_*\fP events which are configured in the Gamepad Bindings section \fBmust be defined here first, or they will be ignored\fP.
.sp
Internally, the axis values are normalized and rescaled between the actual hardware and the value seen by applications, so no clipping or "dead extremes" will occur.  There is no "right" or "wrong" value here that you need to know, but it may be useful to precisely emulate other hardware so it can be detected as such by certain applications which try to guess what kind of device you have.
.sp
The Steam Deck hardware uses signed 16\-bit integers (\fB\-32767\fP to \fB32767\fP) for its thumbstick, trackpad, trigger and motion axes, so there\(cqs no reason to use a larger or smaller range for those inputs, unless you are trying to emulate a specific device.
.sp
.URL "https://en.wikipedia.org/wiki/Joystick#Hat_switch" "\fBHat\-type\fP" ""
axes (\f(CRABS_HAT*\fP) should typically use a range of \f(CR\-1\fP to \f(CR1\fP because of thier historical purpose, but this is not strictly enforced.
.sp
Triggers should typically have \fBminumum value\fP of \f(CR0\fP so that they rest at zero when released.
.sp
Format:
.sp
.if n .RS 4
.nf
.fam C
<abs_event>     = <min>     <max>
.fam
.fi
.if n .RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRabs_event\fP:  Any absolute axis event code you wish to bind.  Absolute event codes begin with \f(CRABS_\fP.  A full list of input event codes can be found at \c
.URL "https://elixir.bootlin.com/linux/latest/source/include/uapi/linux/input\-event\-codes.h" "linux/input\-event\-codes.h" ""
from the Linux kernel.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRmin\fP:  An integer representing the \fBminimum\fP range of the axis.  This is a signed 32\-bit integer.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRmax\fP:  An integer representing the \fBmaximum\fP range of the axis.  This is a signed 32\-bit integer.
.RE
.sp
Example:
.sp
.if n .RS 4
.nf
.fam C
[GamepadAxes]
ABS_HAT0X       = \-1        1
ABS_HAT0Y       = \-1        1
ABS_X           = \-32767    32767
ABS_Y           = \-32767    32767
ABS_RX          = \-32767    32767
ABS_RY          = \-32767    32767
ABS_Z           = 0         32767
ABS_RZ          = 0         32767
.fam
.fi
.if n .RE
.sp
.ce
\l'\n(.lu*25u/100u\(ap'
.bp
.SS "[MotionAxes] Section"
.sp
Motion control absolute axes, as with the gamepad device, must have a defined range or they will not be created.  Any \f(CRMotion\fP \f(CRABS_*\fP events which are configured in the Motion Bindings \fBmust be defined here first, or they will be ignored\fP.
.sp
Internally, the axis values are normalized and rescaled between the actual hardware and the value seen by applications, so no clipping or "dead extremes" will occur.  There is no "right" or "wrong" value here that you need to know, but it may be useful to precisely emulate other hardware so it can be detected as such by certain applications which try to guess what kind of device you have.
.sp
The Steam Deck hardware uses signed 16\-bit integers (\fB\-32767\fP to \fB32767\fP) for its thumbstick, trackpad, trigger and motion axes, so there\(cqs no reason to use a larger or smaller range for those inputs, unless you are trying to emulate a specific device.
.sp
Format:
.sp
.if n .RS 4
.nf
.fam C
<abs_event>     = <min>     <max>
.fam
.fi
.if n .RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRabs_event\fP:  Any absolute axis event code you wish to bind.  Absolute event codes begin with \f(CRABS_\fP.  A full list of input event codes can be found at \c
.URL "https://elixir.bootlin.com/linux/latest/source/include/uapi/linux/input\-event\-codes.h" "linux/input\-event\-codes.h" ""
from the Linux kernel.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRmin\fP:  An integer representing the \fBminimum\fP range of the axis.  This is a signed 32\-bit integer.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRmax\fP:  An integer representing the \fBmaximum\fP range of the axis.  This is a signed 32\-bit integer.
.RE
.sp
Example:
.sp
.if n .RS 4
.nf
.fam C
[MotionAxes]
ABS_X           = \-32767    32767
ABS_Y           = \-32767    32767
ABS_Z           = \-32767    32767
ABS_RX          = \-32767    32767
ABS_RY          = \-32767    32767
ABS_RZ          = \-32767    32767
.fam
.fi
.if n .RE
.if n .sp
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
.B Note
.ps -1
.br
.sp
Motion controls are not yet fully implemented.
.sp .5v
.RE
.sp
.ce
\l'\n(.lu*25u/100u\(ap'
.bp
.SS "[Bindings] Section"
.sp
This should be a list of all the physical gamepad buttons/sticks/pads/motion inputs you want to bind to a virtual input event or command.  Anything not specified here will be considered "unbound" and not emit any event.
.sp
There are currently four basic binding types: \fBdevice bindings\fP, \f(CRCommand\fP bindings, \f(CRProfile\fP bindings and \f(CRNone\fP.
.sp
Device bindings
.RS 4
Represent input events which are generated by pressing buttons, keys, moving the mouse, thumbsticks, motion control, etc.  Event bindings are tied to specific input devices, which include \f(CRGamepad\fP, \f(CRMotion\fP and \f(CRMouse\fP.  Applications read events from these different device types in different ways so they should generally be separated.
.RE
.sp
\f(CRCommand\fP bindings
.RS 4
Executes a given command inside a shell environment.
.RE
.sp
\f(CRProfile\fP bindings
.RS 4
Used to switch to a different profile when triggered.
.RE
.sp
\f(CRNone\fP
.RS 4
This is used to indicate that a particular input has no binding. (default)
.RE
.sp
Input binding names which this document will refer to as \f(CRinput\fP or <input>, are represent physical buttons, triggers, axes, etc. on the physical gamepad portion of the Steam Deck.  They can be broken down into a several categories for simplicity:
.sp
Directional Pad
.RS 4
\f(CRDPad{Up|Down|Left|Right}\fP
.RE
.sp
Buttons
.RS 4
\f(CRA\fP \f(CRB\fP \f(CRX\fP \f(CRY\fP \f(CRL1\fP \f(CRL2\fP \f(CRL3\fP \f(CRL4\fP \f(CRL5\fP \f(CRR1\fP \f(CRR2\fP \f(CRR3\fP \f(CRR4\fP \f(CRR5\fP \f(CRMenu\fP \f(CROptions\fP \f(CRSteam\fP \f(CRQuickAccess\fP
.RE
.sp
Triggers
.RS 4
\f(CR{L|R}Trigg\fP
.RE
.sp
Thumbsticks
.RS 4
\f(CR{L|R}Stick{Up|Down|Left|Right|Touch|Force}\fP
.RE
.sp
Trackpads
.RS 4
\f(CR{L|R}Pad{Up|Down|Left|Right|RelX|RelY|Touch|Press|Force}\fP
.RE
.sp
Accelerometers
.RS 4
\f(CRAccel{X|Y}{Plus|Minus}\fP
.RE
.sp
Attitude / gyros
.RS 4
\f(CR{Roll|Pitch|Yaw}{Plus|Minus}\fP
.RE
.sp
Input names prefixed with \f(CRL\fP or \f(CRR\fP indicate left and right controls (example: \f(CRLStickLeft\fP vs \f(CRRStickLeft\fP)
.sp
\fIAdditionally\fP, trackpads are mapped out into several \fBbutton\fP layouts simultaneously.  This means that when pressed, specific areas of the trackpad behave like individual buttons. There are several "maps" which can be used non\-exclusively.  These are
.sp
Quadrant button maps
.RS 4
\f(CR{L|R}PadPressQuad{Up|Down|Left|Right}\fP
.RE
.sp
Orthogonal button maps
.RS 4
\f(CR{L|R}PadPressOrth{Up|Down|Left|Right}\fP
.RE
.sp
2x2 grid maps
.RS 4
\f(CR{L|R}PadPressGrid2x2_{1|2|3|4}\fP
.RE
.sp
3x3 grid maps
.RS 4
\f(CR{L|R}PadPressGrid3x3_{1|2|3|4|5|6|7|8|9}\fP
.RE
.sp
A full list of available input codes can be seen in the Example Profile section, as well as in \f(CRdefault.profile\fP file.
.sp
\fBA detailed explanation of each of these inputs can be found in the Input Types section.\fP
.sp
.ce
\l'\n(.lu*25u/100u\(ap'
.bp
.SS "Gamepad Bindings"
.sp
The \f(CRGamepad\fP device binding is used to generate input events for a joystick / gamepad\-type device.  This generally means buttons (\f(CRBTN_*\fP) and absolute axis (\f(CRABS_*\fP) events.  \f(CRKEY_*\fP events are allowed, but many programs will not read \f(CRKEY_*\fP events from a joystick device, instead try binding \fBkey\fP events to the \f(CRMouse\fP device.
.sp
The syntax for bindings differs slightly depending on the event type. Absolute axis (\f(CREV_ABS\fP) events are prefixed with \f(CRABS_\fP and key / button events (\f(CREV_KEY\fP) are prefixed with \f(CRKEY_\fP and \f(CRBTN_\fP respectively.  OpenSD supports most event codes.  For a full list of event codes, see \c
.URL "https://elixir.bootlin.com/linux/latest/source/include/uapi/linux/input\-event\-codes.h" "linux/input\-event\-codes.h" ""
from the Linux kernel.
.sp
When bound to a \fBbutton\-type\fP input (example: the \f(CRA\fP button), the bind is triggered when the button is pressed.  When bound to an \fBaxis\-type\fP input (example: \f(CRLStickUp\fP), the event is emitted when the axis is in a non\-zero position and leaves the deadzone (if any).
.sp
\fBFor KEY / BTN events:\fP
.sp
Format:
.sp
.if n .RS 4
.nf
.fam C
input = Gamepad <event_code>
.fam
.fi
.if n .RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRinput\fP: Any one of the input binding names.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRevent_code\fP: Any EV_KEY type event.  These events are prefixed with \f(CRBTN_\fP or \f(CRKEY_\fP.  (example: \f(CRBTN_START\fP or \f(CRKEY_ESCAPE\fP)
.RE
.sp
Example:
.sp
.if n .RS 4
.nf
.fam C
[Bindings]
Menu = Gamepad BTN_START
.fam
.fi
.if n .RE
.sp
\~
.sp
\fBFor ABS events:\fP
.sp
Format:
.sp
.if n .RS 4
.nf
.fam C
input = Gamepad <event_code> <direction>
.fam
.fi
.if n .RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRinput\fP: Any one of the input binding names.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRevent_code\fP: Any \f(CREV_ABS\fP type event.  These events are prefixed with \f(CRABS_\fP.  (example: \f(CRABS_X\fP)
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRdirection\fP: Indicates the direction that the axis is moved in.  Values may be \f(CR+\fP or \f(CR\-\fP.  For centered axes, like thubsticks, \f(CR\-\fP represents moving the axis \fBup\fP or \fBleft\fP, and \f(CR+\fP represents moving the axis \fBdown\fP or \fBright\fP.  For ramped axes, like triggers and pressure sensors, \f(CR+\fP represents applying pressure.
.RE
.sp
When binding a \fBbutton\-type\fP input like a DPad direction or, say, the \f(CRB\fP button to an \fBABS\fP event, the button will push the axis to its \fBmaximum\fP extent in the given direction.  When binding an analog axis, like a thumbstick, to an \fBABS\fP value, the range of motion is mapped to the axis value in the given direction.
.sp
Examples:
.sp
.if n .RS 4
.nf
.fam C
[Bindings]
# Button mapped to an axis
DPadUp          = Gamepad   ABS_HAT0Y   \-

# Analogue stick mapped to an axis
RStickUp        = Gamepad   ABS_Y       \-
RStickDown      = Gamepad   ABS_Y       +

# Analogue trigger mapped to an axis
LTrigg          = Gamepad   ABS_Z       +
.fam
.fi
.if n .RE
.sp
A full list of gamepad input names can be seen in the Example Profile section.
.sp
\fBA detailed explanation of inputs can be found in the Input Types section of this document.\fP
.if n .sp
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
.B Note
.ps -1
.br
.sp
\fBABS\fP events must have a defined range in the [GamepadAxes] Section
.sp .5v
.RE
.sp
.ce
\l'\n(.lu*25u/100u\(ap'
.bp
.SS "Motion Bindings"
.sp
The \f(CRMotion\fP device binding is used to generate input events for a motion control\-type device.  While OpenSD does not strictly enforce this, the Linux kernel and uinput specify that motion control events should be emitted by separate devices.  Not doing so can create a lot of "noise", especially when configuring controls within another application.  As per this spec, the \f(CRMotion\fP device only supports \f(CREV_ABS\fP type events.  These events are prefixed with \f(CRABS_\fP  (example: \f(CRABS_Z\fP).  For a full list of event codes, see \c
.URL "https://elixir.bootlin.com/linux/latest/source/include/uapi/linux/input\-event\-codes.h" "linux/input\-event\-codes.h" ""
from the Linux kernel.
.sp
The syntax and behaviour for binding \f(CRMotion\fP device events is the same as binding \fBABS\fP events with the \f(CRGamepad\fP device in the previous section.
.sp
Also, the \f(CRMotion\fP device is a completely separate context and namespace from the \f(CRGamepad\fP and \f(CRMouse\fP devices, much in the same way that two players with identical controllers will have the same buttons, but very different meanings to the game.  For example, pressing \f(CRA\fP on controller #1 does not affect player #2.  Its up the the end\-user\(cqs software to decide the the context and meaning of the individual events.
.sp
Format:
.sp
.if n .RS 4
.nf
.fam C
input = Motion <event_code> <direction>
.fam
.fi
.if n .RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRinput\fP: Any one of the input binding names.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRevent_code\fP: Any \f(CREV_ABS\fP type event.  These events are prefixed with \f(CRABS_\fP.  (example: \f(CRABS_X\fP)
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRdirection\fP: Indicates the direction that the axis is moved in.  Values may be \f(CR+\fP or \f(CR\-\fP.
.RE
.sp
Examples:
.sp
.if n .RS 4
.nf
.fam C
[Bindings]
# Bind roll attitude to Motion device
RollPlus        = Motion    ABS_X       +
RollMinus       = Motion    ABS_X       \-
.fam
.fi
.if n .RE
.sp
A full list of motion contol input names can be seen in the Example Profile section.
.sp
\fBA detailed explanation of motion input be found in the Input Types section of this document.\fP
.if n .sp
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
.B Note
.ps -1
.br
.sp
\fBABS\fP events must have a defined range in the [MotionAxes] Section
.sp .5v
.RE
.if n .sp
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
.B Note
.ps -1
.br
.sp
This feature is not yet fully implemented.
.sp .5v
.RE
.sp
.ce
\l'\n(.lu*25u/100u\(ap'
.bp
.SS "Mouse Bindings"
.sp
The \f(CRMouse\fP device binding is used to generate input events which will be interpreted as events coming from a pointer\-type device such as a physical mouse.  This binding type supports \fBbutton\fP / \fBkey\fP and \fBrelative axis\fP events.  The \f(CRMouse\fP device can also function a bit like a keyboard, so it\(cqs advised to bind any \fBkey\fP events to this device.
.sp
The syntax for bindings differs slightly depending on the event type. \fBRelative axis\fP (\f(CREV_REL\fP) events are prefixed with \f(CRREL_\fP and \fBkey\fP / \fBbutton\fP events (\f(CREV_KEY\fP) are prefixed with \f(CRKEY_\fP and \f(CRBTN_\fP respectively.  OpenSD supports most event codes.  For a full list of event codes, see \c
.URL "https://elixir.bootlin.com/linux/latest/source/include/uapi/linux/input\-event\-codes.h" "linux/input\-event\-codes.h" ""
from the Linux kernel.
.sp
\fBFor KEY / BTN events:\fP
.sp
.if n .RS 4
.nf
.fam C
input = Mouse <event_code>
.fam
.fi
.if n .RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRinput\fP: Any one of the input binding names.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRevent_code\fP: Any EV_KEY type event.  These events are prefixed with \f(CRBTN_\fP or \f(CRKEY_\fP.  (example: \f(CRBTN_LEFT\fP or \f(CRKEY_ESCAPE\fP)
.RE
.sp
Example:
.sp
.if n .RS 4
.nf
.fam C
[Bindings]
RPadPress       = Mouse BTN_LEFT
QuickAccess     = Mouse BTN_RIGHT
.fam
.fi
.if n .RE
.sp
\fBFor REL events:\fP
.sp
.if n .RS 4
.nf
.fam C
[Bindings]
RPadRelX        = Mouse REL_X
RPadRelY        = Mouse REL_Y
.fam
.fi
.if n .RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRinput\fP: Any one of the input binding names.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRevent_code\fP: Any \f(CREV_REL\fP type event.  These events are prefixed with \f(CRREL_\fP.  (example: \f(CRREL_X\fP)
.RE
.sp
\fBPlease see the Trackpads section of this document for a better explanation of how \f(CR{L|R}PadRel{X|Y}\fP relative inputs work.\fP
.sp
.ce
\l'\n(.lu*25u/100u\(ap'
.bp
.SS "Command Bindings"
.sp
The \f(CRCommand\fP binding allows you to execute external programs or scripts by forking them off as a child process.  These processes run concurrently, do not return any usable exit code, and will not interrupt the driver.
.sp
Format:
.sp
.if n .RS 4
.nf
.fam C
input = Command <wait_for_exit> <repeat_delay_ms> <command_to_execute>
.fam
.fi
.if n .RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRinput\fP: Any one of the input binding names.  Best suited to button\-types.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRwait_for_exit\fP: a \f(CRtrue\fP or \f(CRfalse\fP value which specifies if the command should complete before the binding can be triggered again.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRrepeat_delay_ms\fP: The amount of time \fBin milliseconds\fP that must elapse before the binding can be triggered again.  The timer starts when the binding is successfully triggered.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRcommand_to_execute\fP: The name of the command / script you want to run, same as you would from a terminal.  The command executes normally inside a shell, so variable expansion should work.  Arguments may be specfied by placing them after the command as usual.
.RE
.sp
Example:
.sp
.if n .RS 4
.nf
.fam C
[Bindings]
QuickAccess     = Command   true    0   rofi \-show run
.fam
.fi
.if n .RE
.sp
.ce
\l'\n(.lu*25u/100u\(ap'
.bp
.SS "Profile Bindings"
.sp
The \f(CRProfile\fP binding type allows you to switch to a different profile using just the gamepad input.  Profiles are loaded from the user profile directory.  There is a \fB2 second\fP delay after profile switching before the profile can be changed again, to prevent undesirable rapid cycling.  If a profile fails to load, the process will be aborted and the profile currently in use will remain so.
.sp
Format:
.sp
.if n .RS 4
.nf
.fam C
input = Profile <profile_name>
.fam
.fi
.if n .RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRinput\fP: Any one of the input binding names.  Best suited to button\-types.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRprofile_name\fP: Filename of the profile ini you want to load.  Path is fixed to the user profile directory, so \fBonly\fP specify the filename itself.
.RE
.sp
Example:
.sp
.if n .RS 4
.nf
.fam C
[Bindings]
L5      = Profile   left_hand_mouse.profile
.fam
.fi
.if n .RE
.sp
\~
.br
\~
.sp
.ce
\l'\n(.lu*25u/100u\(ap'
.bp
.SS "Input Types"
.sp
As briefly described in the [Bindings] Section, the gamepad has multiple input components which can be categorized by their interface, but also by a primitive type. For example, the thumbsticks on the Steam Deck have a pair of \fBX\fP / \fBY\fP axes (example: \f(CRLStickUp\fP, \f(CRLStickLeft\fP), which, as a primitive type are absolute, but the thumbsticks \fIalso\fP have a \fBtouch sensor\fP at the top which can be read as a binary \fBbutton\fP primitive (\f(CRLStickTouch\fP) as well as a pressure level (\f(CRLStickForce\fP) which is read as a single \fBabsolute axis\fP like a \fBtrigger\fP would be.
.sp
The intent is for each input name to be as \fIsimple and intuitive as possible\fP, but that\(cqs always going to be pretty subjective.  This section intends to provide a painfully detailed explanation for every individual input that can have a \fBbinding\fP ; )
.SS "Directional Pad"
.sp
The directional pad is just a set of four buttons which are diametrically exclusive \(em you can press \fBup\fP and \fBleft\fP simultaneously but you cannot press \fBleft\fP and \fBright\fP simultaneously.
.sp
Naming Convention
.RS 4
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRDPad{Up|Down|Left|Right}\fP
.RE
.RE
.sp
Descriptions
.RS 4
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRDPadUp\fP: The top button on the directional pad.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRDPadDown\fP: The botton button on the directional pad.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRDPadLeft\fP: The left button on the directional pad.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRDPadRight\fP: The right button on the directional pad.
.RE
.RE
.sp
Use
.RS 4
While you can bind them to nearly anything, these buttons are usually bound to pair of \c
.URL "https://en.wikipedia.org/wiki/Joystick#Hat_switch" "\fBHat\fP" ""
axes, which are \fItypically\fP axes with a range of \fB\-1\fP to \fB1\fP and \fB0\fP when resting / released.
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
Button bindings to \f(CRKEY_\fP and \f(CRBTN_\fP events work directly as you might expect.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
Buttons bound to \f(CRABS_\fP events emit the axis limit in the given direction.
.RE
.RE
.sp
A common configuration as seen in the Example Profile might look like this:
.sp
.if n .RS 4
.nf
.fam C
[Bindings]
DpadUp              = Gamepad   ABS_HAT0Y   \-
DpadDown            = Gamepad   ABS_HAT0Y   +
DpadLeft            = Gamepad   ABS_HAT0X   \-
DpadRight           = Gamepad   ABS_HAT0X   +
.fam
.fi
.if n .RE
.sp
.ce
\l'\n(.lu*25u/100u\(ap'
.SS "Buttons"
.sp
These are pretty straightforward. As you probably expect, buttons have two states.  They\(cqre \fBtrue\fP when pressed and \fBfalse\fP when released.  The Steam Deck borrows common names for most buttons, but also adds a few of it\(cqs own.  It\(cqs debatable how to organize or classify these, so I\(cqll just sorta go by the legacy naming standards.
.sp
Naming conventions
.RS 4
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRA\fP \f(CRB\fP \f(CRX\fP \f(CRY\fP \f(CR{L|R}{1|2|3|4|5}\fP \f(CRMenu\fP \f(CROptions\fP \f(CRSteam\fP \f(CRQuickAccess\fP
.RE
.RE
.sp
Descriptions
.RS 4
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRA\fP: Same as it appears on the front of the Steam Deck.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRB\fP: Same as it appears on the front of the Steam Deck.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRX\fP: Same as it appears on the front of the Steam Deck.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRY\fP: Same as it appears on the front of the Steam Deck.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRL1\fP: The top \fBleft\fP bumper / shoulder button.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRR1\fP: The top \fBright\fP bumper / shoulder button.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRL2\fP: Button nested inside the pressure sensor of the \fBleft\fP trigger.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRR2\fP: Button nested inside the pressure sensor of the \fBright\fP trigger.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRL3\fP: Button nested at the bottom of the \fBleft\fP stick.  Activated by pressing down until it clicks.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRR3\fP: Button nested at the bottom of the \fBright\fP stick.  Activated by pressing down until it clicks.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRL4\fP: Upper paddle button located on the \fBback\-left\fP side of the Steam Deck.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRR4\fP: Upper paddle button located on the \fBback\-right\fP side of the Steam Deck.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRL5\fP: Lower paddle button located on the \fBback\-left\fP side of the Steam Deck.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRR5\fP: Lower paddle button located on the \fBback\-right\fP side of the Steam Deck.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRMenu\fP: Raised \c
.URL "https://en.wikipedia.org/wiki/Hamburger_button" "hamburger button" ""
(☰) located above the *right *thumbstick.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CROptions\fP: Raised overlapped rectangle button (⮻) located above the \fBleft\fP thumbstick.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRSteam\fP: Flat button of the same name (STEAM), located below the \fBleft\fP trackpad.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRQuickAccess\fP: Flat button with three interpuncts (···), located below the \fBright\fP trackpad.
.RE
.RE
.sp
Use
.RS 4
Binding buttons is simple.
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
Button bindings to \f(CRKEY_\fP and \f(CRBTN_\fP events work directly.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
Buttons bound to \f(CRABS_\fP events emit the axis limit in the given direction.  For example, if you create a binding like \f(CRA = ABS_X +\fP, then when you press the \f(CRA\fP button, it will emit an \f(CRABS_X\fP event for whatever the \fBmaximum\fP axis limit for \f(CRABS_X\fP is, whereas \f(CRA = ABS_X \-\fP will emit the \fBminimum\fP axis limit.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRA\fP/\f(CRB\fP/\f(CRX\fP/\f(CRY\fP have respective input codes for \f(CRGamepad\fP devices: \f(CRBTN_SOUTH\fP, \f(CRBTN_EAST\fP, \f(CRBTN_WEST\fP and \f(CRBTN_NORTH\fP.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CR{L|R}{1|2}\fP have respective input codes for \f(CRGamepad\fP devices: \f(CRBTN_TL\fP \f(CRBTN_TL2\fP \f(CRBTN_TR\fP and \f(CRBTN_TR2\fP.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CR{L|R}3\fP have respective input codes for \f(CRGamepad\fP devices: \f(CRBTN_THUMBL\fP and \f(CRBTN_THUMBR\fP
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRMenu\fP has a respective (based on location and common use) input code for \f(CRGamepad\fP devices: \f(CRBTN_START\fP.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CROptions\fP has a respective (based on location and common use) input code for \f(CRGamepad\fP devices: \f(CRBTN_SELECT\fP.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRSteam\fP is probably closest to a PS or HOME button on a \f(CRGamepad\fP device; possibly use \f(CRBTN_MODE\fP.
.RE
.RE
.sp
.ce
\l'\n(.lu*25u/100u\(ap'
.SS "Thumbsticks"
.sp
The thumbsticks on the Steam Deck are associated with six different inputs in OpenSD.  As you would expect, there is an \fBX\fP/\fBY\fP axis pair for each stick, but there are also \fBtouch\fP and \fBpressure\fP (well, sorta) sensors located on the top of each one.  The directional axes are broken into halves such that each direction can emit different events if desired.
.sp
Axis values from thumbsticks are normalized internally so they can be rescaled to the defined \fBABS\fP event ranges.  The hardware returns signed 16\-bit integer values for axis values in the HID reports.  The "pressure sensor" component has a very short numerical range, but is quite sensitive.
.sp
If StickFiltering is enabled the full axis is internally normalized as a unit vector and a \fBradial deadzone\fP may be applied.
.sp
Naming convention
.RS 4
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CR{L|R}Stick{Up|Down|Left|Right|Touch|Force}\fP
.RE
.RE
.sp
Descriptions
.RS 4
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRLStickUp\fP: Represents the top half of the \fBY\-axis\fP of the \fBleft\fP thumbstick.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRLStickDown\fP: Represents the bottom half of the \fBY\-axis\fP of the \fBleft\fP thumbstick.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRLStickLeft\fP: Represents the left half of the \fBX\-axis\fP of the \fBleft\fP thumbstick.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRLStickRight\fP: Represents the right half of the \fBX\-axis\fP of the \fBleft\fP thumbstick.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRLStickTouch\fP: This is a binary \fBbutton\fP that return \fBtrue\fP when the top of the \fBleft\fP thumbstick is touched.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRLStickForce\fP: This is a weird kind of proximity/pressure sensor at the top of the \fBleft\fP thumbstick.  It is \fIvery\fP sensitive and can register if your hand is \fInear\fP, without actually touching it.  At a hardware level, the sensitivity ranges from \fB0\fP to \fB~112\fP, which is an odd number.  This value is returned as an normalized axis (\fB0\fP to \fB1.0\fP), just like a trigger.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRRStickUp\fP: Represents the top half of the \fBY axis\fP of the \fBright\fP thumbstick.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRRStickDown\fP: Represents the bottom half of the \fBY axis\fP of the \fBright\fP thumbstick.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRRStickLeft\fP: Represents the left half of the \fBX axis\fP of the \fBright\fP thumbstick.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRRStickRight\fP: Represents the right half of the \fBX axis\fP of the \fBright\fP thumbstick.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRRStickTouch\fP: This is a binary \fBbutton\fP that return \fBtrue\fP when the top of the \fBright\fP thumbstick is touched.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRRStickForce\fP: This is a weird kind of proximity/pressure sensor at the top of the \fBright\fP thumbstick.  It is \fIvery\fP sensitive and can register if your hand is \fInear\fP, without actually touching it.  At a hardware level, the sensitivity ranges from \fB0\fP to \fB~112\fP, which is an odd number.  This value is returned as an normalized axis (\fB0\fP to \fB1.0\fP), just like a trigger.
.RE
.RE
.sp
Use
.RS 4
Directional inputs are treated like axis halves.  You typically want to map \f(CRUp\fP and \f(CRDown\fP onto the same \fBABS\fP event code, but in opposite directions. Doing so will perfectly map the full range of motion to an event code.  An example of this, as demonstrated in the \fB[Bindings]\fP section of the Example Profile:
.RE
.sp
.if n .RS 4
.nf
.fam C
# Left Stick
LStickUp            = Gamepad   ABS_Y       \-
LStickDown          = Gamepad   ABS_Y       +
LStickLeft          = Gamepad   ABS_X       \-
LStickRight         = Gamepad   ABS_X       +
# Right Stick
RStickUp            = Gamepad   ABS_RY      \-
RStickDown          = Gamepad   ABS_RY      +
RStickLeft          = Gamepad   ABS_RX      \-
RStickRight         = Gamepad   ABS_RX      +
.fam
.fi
.if n .RE
.sp
You\(cqre also able to treat each axis half like a \fBbutton\fP if you bind it to a \fBkey\fP or \fBbutton\fP event code, in which case it will trigger the binding when the stick leaves the \fBcenter\fP / \fBdeadzone\fP.  You can use the deadzone in this case to determine how far the stick must be pushed from center before the binding is triggered.
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRLStickLeft\fP & \f(CRLStickRight\fP are typically bound to the \f(CRABS_X\fP event code on \f(CRGamepad\fP devices.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRLStickUp\fP & \f(CRLStickDown\fP are typically bound to the \f(CRABS_Y\fP event code on \f(CRGamepad\fP devices.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRRStickLeft\fP & \f(CRRStickRight\fP are typically bound to the \f(CRABS_RX\fP event code on \f(CRGamepad\fP devices.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRRStickUp\fP & \f(CRRStickDown\fP are typically bound to the \f(CRABS_RY\fP event code on \f(CRGamepad\fP devices.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
Use \f(CRLStickTouch\fP / \f(CRRStickTouch\fP to detect if a players hands are on the controls.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
Use \f(CRLStickForce\fP / \f(CRRStickForce\fP only if you want to write a tiny electric theremin simulator?  If this sensor is bound to an axis, a range of \fB0\fP to \fB100\fP is recommened.
.RE
.sp
.ce
\l'\n(.lu*25u/100u\(ap'
.SS "Triggers"
.sp
Triggers are pressure sensors that are also treated a bit like a thumbstick\(cqs half\-axis, with the difference being there\(cqs no complement half.  Triggers have a resting position of the defined axis \fBminimum\fP limit and move toward the \fBmaximum\fP limit when actuated.  \fITypically\fP the minimum limit is zero, so the axis does not return non\-zero values when released / resting, but you can do any weird thing you want.
.sp
Axis values from triggers are normalized internally so they can be rescaled to the defined \fBABS\fP event ranges.  Internally, the HID reports return trigger values as unsigned 16\-bit integers.
.sp
Triggers also have a binary \fBbutton\fP component: \f(CRL2\fP and \f(CRR2\fP.  Information about these buttons can be found in the Buttons section.
.sp
Linear deadzones can be applied to triggers, if desired in the [Deadzones] Section.
.sp
Naming convention
.RS 4
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CR{L|R}Trigg\fP
.RE
.RE
.sp
Descriptions
.RS 4
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRLTrigg\fP: Represents a pressure sensor value for the \fBleft\fP trigger on the top\-rear of the device.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRRTrigg\fP: Represents a pressure sensor value for the \fBright\fP trigger on the top\-rear of the device.
.RE
.RE
.sp
Use
.RS 4
These inputs are absolute axes and can be mapped to \fBABS\fP event codes as well as \fBKEY\fP / \fBBTN\fP event codes.  One possible reason to use the axis itself as a \fBbutton\fP\-type binding would be to use \f(CRL2\fP / \f(CRR2\fP buttons on partial actuation, and use a deadzone to emit another event code on full actuation.
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRLTrigg\fP is typically bound to \f(CRABS_Z\fP.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRRTrigg\fP is typically bound to \f(CRABS_RZ\fP.
.RE
.RE
.sp
.ce
\l'\n(.lu*25u/100u\(ap'
.SS "Trackpads"
.sp
At the core, trackpads are \fBabsolute axis\fP devices have with an \fBX\fP / \fBY\fP pair, as well as a pressure sensor \fBZ\-axis\fP and a slightly tactile \fBbutton\fP.  A number of inputs can be extrapolated from the data those basic types provide.  That includes \fBtouch\fP sensors, \fBpress / button\fP sensors, \fBpressure / force\fP sensors, \fBabsolute coordinates\fP, \fBrelative movement\fP tracking as well as the ability to \fBmap\fP out regions of the pad and treat them as individual \fBbuttons\fP.  OpenSD trackpads have the most input bindings out of all the components.
.sp
As with the Thumbsticks, directional axes are broken into halves such that each direction can emit different events if desired.  These halves can be mapped on to a whole \fBABS\fP event code, or use separately.
.sp
Trackpads support radial deadzones for \fBabsolute axis\fP inputs, and can be configured in the [Deadzones] Section.
.sp
\fBRelative\fP trackpad input, such as \f(CRLPadRelX\fP or \f(CRLPadRelY\fP, are not affected by deadzones and return data suitable for pointing devices like mice.  These return the \fBdifference\fP in positional movement calculated between HID frames.  Some filtering is always applied to this process to reduce jitter and a small amount of intertia is also applied.  The typical value range returned by these inputs is usually between \fB\-5\fP and \fB+5\fP.  Binding \f(CR\fBRelX\fP and \f(CR*RelY\fP inputs to anything other than \f(CRREL_\fP\fP event codes on the \f(CRMouse\fP device is probably not useful.
.sp
Touchpads are non\-multitouch devices so they only relay a single \fBX\fP / \fBY\fP coordinate pair.
.sp
OpenSD provides multiple \fB"button maps"\fP, any of which can be used non\-exclusively with each other.  These "button maps" break the full area of the trackpad into logical sections which, when \fBpressed\fP (as opposed to being merely touched) act as individual buttons.  If so desired, trackpads can be used to create "button clusters", which can be used to emulate a Directional Pad, \fBarrow keys\fP, run scripts, launch applications, etc.  For the sake of readability, button maps are described separately below the main input descriptions.
.sp
Naming convention
.RS 4
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CR{L|R}Pad{Up|Down|Left|Right|Touch|Press|Force|RelX|RelY}\fP
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CR{L|R}PadPressQuad{Up|Down|Left|Right}\fP
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CR{L|R}PadPressOrth{Up|Down|Left|Right}\fP
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CR{L|R}PadPressGrid2x2_{1|2|3|4}\fP
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CR{L|R}PadPressGrid3x3_{1|2|3|4|5|6|7|8|9}\fP
.RE
.RE
.sp
Descriptions
.RS 4
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRLPadUp\fP: Represents the top half of the \fBY\-axis\fP of the \fBleft\fP trackpad.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRLPadDown\fP: Represents the bottom half of the \fBY\-axis\fP of the \fBleft\fP trackpad.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRLPadLeft\fP: Represents the left half of the \fBX\-axis\fP of the \fBleft\fP trackpad.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRLPadRight\fP: Represents the right half of the \fBX\-axis\fP of the \fBleft\fP trackpad.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRLPadTouch\fP: This is a button sensor which detects if the \fBleft\fP pad is being touched.  Quite sensitive.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRLPadPress\fP: This is also a button which detects if the \fBleft\fP pad is being pressed down like a button.  Actuation has a slight tactile bump.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRLPadForce\fP: This is a pressure sensor which returns a normalized value of how much force is being used to press down on the \fBleft\fP trackpad.  This is an \fBabsolute axis\fP value and behaves the same as Triggers.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRLPadRelX\fP: This is a derived \fBrelative axis\fP value that measures the amount of relative \fBX\-axis\fP movement between update frames of the \fBleft\fP trackpad.  This represents the same kind of input data that mice use.  This input is unaffected by deadzones.  Typical values returned fall inside the range of \fB\-5\fP to \fB+5\fP.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRLPadRelY\fP: This is a derived \fBrelative axis\fP value that measures the amount of relative \fBY\-axis\fP movement between update frames of the \fBleft\fP trackpad.  This represents the same kind of input data that mice use.  This input is unaffected by deadzones.  Typical values returned fall inside the range of \fB\-5\fP to \fB+5\fP.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRRPadUp\fP: Represents the top half of the \fBY\-axis\fP of the \fBright\fP trackpad.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRRPadDown\fP: Represents the bottom half of the \fBY\-axis\fP of the \fBright\fP trackpad.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRRPadLeft\fP: Represents the left half of the \fBX\-axis\fP of the \fBright\fP trackpad.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRRPadRight\fP: Represents the right half of the \fBX\-axis\fP of the \fBright\fP trackpad.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRRPadTouch\fP: This is a button sensor which detects if the \fBright\fP pad is being touched.  Quite sensitive.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRRPadPress\fP: This is also a button which detects if the \fBright\fP pad is being pressed down like a button.  Actuation has a slight tactile bump.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRRPadForce\fP: This is a pressure sensor which returns a normalized value of how much force is being used to press down on the \fBright\fP trackpad.  This is an \fBabsolute axis\fP value and behaves the same as Triggers.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRRPadRelX\fP: This is a derived \fBrelative axis\fP value that measures the amount of relative \fBX\-axis\fP movement between update frames of the \fBright\fP trackpad.  This represents the same kind of input data that mice use.  This input is unaffected by deadzones.  Typical values returned fall inside the range of \fB\-5\fP to \fB+5\fP.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRRPadRelY\fP: This is a derived \fBrelative axis\fP value that measures the amount of relative \fBY\-axis\fP movement between update frames of the \fBright\fP trackpad.  This represents the same kind of input data that mice use.  This input is unaffected by deadzones.  Typical values returned fall inside the range of \fB\-5\fP to \fB+5\fP.
.RE
.RE
.SS "Quadrant Button Map"
.sp
The \fBquadrant map\fP (\f(CRPadPressQuad*\fP) provides a way to treat each touchpad as being composed of four \fBnon\-overlapping\fP triagular quadrants, as depicted in the \fBfigure 1\fP below.  Each \fBbutton\fP is inherently exclusive to the others in this map since the \fBX\fP / \fBY\fP coordinate can only fall inside of one of these regions at a time.  This means that this map will not detect any overlapping presses, like \fBa\fP and \fBb\fP when you press in the upper\-left region.
.sp
Fig. 1
.sp
.if n .RS 4
.nf
.fam C
┌─────────────┐
│ \(rs         / │
│  \(rs   a   /  │
│   \(rs     /   │
│    \(rs   /    │
│     \(rs /     │
│ b    X    c │
│     / \(rs     │
│    /   \(rs    │
│   /     \(rs   │
│  /   d   \(rs  │
│ /         \(rs │
└─────────────┘
.fam
.fi
.if n .RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRLPadPressQuadUp\fP: The logical \fBbutton\fP on the \fBleft\fP trackpad corresponding to \fBfig. 1\fP, region \fB"a"\fP.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRLPadPressQuadDown\fP: The logical \fBbutton\fP on the \fBleft\fP trackpad corresponding to \fBfig. 1\fP, region \fB"d"\fP.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRLPadPressQuadLeft\fP: The logical \fBbutton\fP on the \fBleft\fP trackpad corresponding to \fBfig. 1\fP, region \fB"b"\fP.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRLPadPressQuadRight\fP: The logical \fBbutton\fP on the \fBleft\fP trackpad corresponding to \fBfig. 1\fP, region \fB"c"\fP.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRRPadPressQuadUp\fP: The logical \fBbutton\fP on the \fBright\fP trackpad corresponding to \fBfig. 1\fP, region \fB"a"\fP.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRRPadPressQuadDown\fP: The logical \fBbutton\fP on the \fBright\fP trackpad corresponding to \fBfig. 1\fP, region \fB"d"\fP.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRRPadPressQuadLeft\fP: The logical \fBbutton\fP on the \fBright\fP trackpad corresponding to \fBfig. 1\fP, region \fB"b"\fP.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRRPadPressQuadRight\fP: The logical \fBbutton\fP on the \fBright\fP trackpad corresponding to \fBfig. 1\fP, region \fB"c"\fP.
.RE
.sp
.ce
\l'\n(.lu*25u/100u\(ap'
.SS "Orthogonal Button Map"
.sp
The \fBorthogonal map\fP (\f(CRPadPressOrth*\fP) works similarly to a Directional Pad.  As you can see below in figure 2, it demonstrates how the \fB"a"\fP, \fB"b"\fP, \fB"c"\fP and \fB"d"\fP regions represent orthogonal directions which are not strictly exclusive as they are with the Quadrant Button Map.  If a diagonal corner is pressed, it triggers both orthogonally adjacent buttons.  For example, pressing the upper\-middle of the pad only triggers \fB"a"\fP, but pressing the upper\-left of the pad will trigger both \fB"a"\fP and \fB"b"\fP.
.sp
Fig. 2
.sp
.if n .RS 4
.nf
.fam C
┌─────┬─────┬─────┐
│     │     │     │
│  ab │  a  │  ac │
│     │     │     │
├─────┼─────┼─────┤
│     │     │     │
│  b  │     │  c  │
│     │     │     │
├─────┼─────┼─────┤
│     │     │     │
│  db │  d  │  dc │
│     │     │     │
└─────┴─────┴─────┘
.fam
.fi
.if n .RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRLPadPressOrthUp\fP: The logical \fBbutton\fP on the \fBleft\fP trackpad corresponding to \fBfig. 2\fP regions containing \fB"a"\fP.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRLPadPressOrthDown\fP: The logical \fBbutton\fP on the \fBleft\fP trackpad corresponding to \fBfig. 2\fP regions containing \fBd"\fP.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRLPadPressOrthLeft\fP: The logical \fBbutton\fP on the \fBleft\fP trackpad corresponding to \fBfig. 2\fP regions containing \fB"b"\fP.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRLPadPressOrthRight\fP: The logical \fBbutton\fP on the \fBleft\fP trackpad corresponding to \fBfig. 2\fP regions containing \fB"c"\fP.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRRPadPressOrthUp\fP: The logical \fBbutton\fP on the \fBright\fP trackpad corresponding to \fBfig. 2\fP regions containing \fB"a"\fP.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRRPadPressOrthDown\fP: The logical \fBbutton\fP on the \fBright\fP trackpad corresponding to \fBfig. 2\fP regions containing \fBd"\fP.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRRPadPressOrthLeft\fP: The logical \fBbutton\fP on the \fBright\fP trackpad corresponding to \fBfig. 2\fP regions containing \fB"b"\fP.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRRPadPressOrthRight\fP: The logical \fBbutton\fP on the \fBright\fP trackpad corresponding to \fBfig. 2\fP regions containing \fB"c"\fP.
.RE
.sp
.ce
\l'\n(.lu*25u/100u\(ap'
.SS "2x2 Grid Button Map"
.sp
This button map divides the pad into regions along the center axes, resulting in four square \fBbuttons\fP in each corner, as depicted in figure 3.  Buttons are naturally exclusive, so only one can be pressed at a time.  Buttons are enumerated left\-to\-right, top\-to\-bottom.
.sp
Fig. 3
.sp
.if n .RS 4
.nf
.fam C
┌────────┬────────┐
│        │        │
│        │        │
│   a    │    c   │
│        │        │
│        │        │
├────────┼────────┤
│        │        │
│        │        │
│   c    │    d   │
│        │        │
│        │        │
└────────┴────────┘
.fam
.fi
.if n .RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRLPadPressGrid2x2_1\fP: The logical \fBbutton\fP on the \fBleft\fP trackpad corresponding to \fBfig. 3\fP, region \fB"a"\fP.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRLPadPressGrid2x2_2\fP: The logical \fBbutton\fP on the \fBleft\fP trackpad corresponding to \fBfig. 3\fP, region \fB"b"\fP.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRLPadPressGrid2x2_3\fP: The logical \fBbutton\fP on the \fBleft\fP trackpad corresponding to \fBfig. 3\fP, region \fB"c"\fP.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRLPadPressGrid2x2_4\fP: The logical \fBbutton\fP on the \fBleft\fP trackpad corresponding to \fBfig. 3\fP, region \fB"d"\fP.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRRPadPressGrid2x2_1\fP: The logical \fBbutton\fP on the \fBright\fP trackpad corresponding to \fBfig. 3\fP, region \fB"a"\fP.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRRPadPressGrid2x2_2\fP: The logical \fBbutton\fP on the \fBright\fP trackpad corresponding to \fBfig. 3\fP, region \fB"b"\fP.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRRPadPressGrid2x2_3\fP: The logical \fBbutton\fP on the \fBright\fP trackpad corresponding to \fBfig. 3\fP, region \fB"c"\fP.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRRPadPressGrid2x2_4\fP: The logical \fBbutton\fP on the \fBright\fP trackpad corresponding to \fBfig. 3\fP, region \fB"d"\fP.
.RE
.sp
.ce
\l'\n(.lu*25u/100u\(ap'
.SS "3x3 Grid Button Map"
.sp
This button map divides the pad into thirds along both axes, resulting in a 3x3 grid of nine square \fBbuttons\fP, as depicted in figure 4.  These buttons are naturally exclusive to one another, so only one can be pressed at a time.  Buttons are enumerated left\-to\-right, top\-to\-bottom.
.if n .sp
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
.B Note
.ps -1
.br
.sp
The resulting size of each button will be fairly small, so it may require a little practice and small thumbs to manipulate them precisely.
.sp .5v
.RE
.sp
Fig. 4
.sp
.if n .RS 4
.nf
.fam C
┌─────┬─────┬─────┐
│     │     │     │
│  a  │  b  │  c  │
│     │     │     │
├─────┼─────┼─────┤
│     │     │     │
│  d  │  e  │  f  │
│     │     │     │
├─────┼─────┼─────┤
│     │     │     │
│  g  │  h  │  i  │
│     │     │     │
└─────┴─────┴─────┘
.fam
.fi
.if n .RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRLPadPressGrid3x3_1\fP: The logical \fBbutton\fP on the \fBleft\fP trackpad corresponding to \fBfig. 4\fP, region \fB"a"\fP.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRLPadPressGrid3x3_2\fP: The logical \fBbutton\fP on the \fBleft\fP trackpad corresponding to \fBfig. 4\fP, region \fB"b"\fP.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRLPadPressGrid3x3_3\fP: The logical \fBbutton\fP on the \fBleft\fP trackpad corresponding to \fBfig. 4\fP, region \fB"c"\fP.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRLPadPressGrid3x3_4\fP: The logical \fBbutton\fP on the \fBleft\fP trackpad corresponding to \fBfig. 4\fP, region \fB"d"\fP.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRLPadPressGrid3x3_5\fP: The logical \fBbutton\fP on the \fBleft\fP trackpad corresponding to \fBfig. 4\fP, region \fB"e"\fP.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRLPadPressGrid3x3_6\fP: The logical \fBbutton\fP on the \fBleft\fP trackpad corresponding to \fBfig. 4\fP, region \fB"f"\fP.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRLPadPressGrid3x3_7\fP: The logical \fBbutton\fP on the \fBleft\fP trackpad corresponding to \fBfig. 4\fP, region \fB"g"\fP.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRLPadPressGrid3x3_8\fP: The logical \fBbutton\fP on the \fBleft\fP trackpad corresponding to \fBfig. 4\fP, region \fB"h"\fP.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRLPadPressGrid3x3_9\fP: The logical \fBbutton\fP on the \fBleft\fP trackpad corresponding to \fBfig. 4\fP, region \fB"i"\fP.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRRPadPressGrid3x3_1\fP: The logical \fBbutton\fP on the \fBright\fP trackpad corresponding to \fBfig. 4\fP, region \fB"a"\fP.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRRPadPressGrid3x3_2\fP: The logical \fBbutton\fP on the \fBright\fP trackpad corresponding to \fBfig. 4\fP, region \fB"b"\fP.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRRPadPressGrid3x3_3\fP: The logical \fBbutton\fP on the \fBright\fP trackpad corresponding to \fBfig. 4\fP, region \fB"c"\fP.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRRPadPressGrid3x3_4\fP: The logical \fBbutton\fP on the \fBright\fP trackpad corresponding to \fBfig. 4\fP, region \fB"d"\fP.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRRPadPressGrid3x3_5\fP: The logical \fBbutton\fP on the \fBright\fP trackpad corresponding to \fBfig. 4\fP, region \fB"e"\fP.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRRPadPressGrid3x3_6\fP: The logical \fBbutton\fP on the \fBright\fP trackpad corresponding to \fBfig. 4\fP, region \fB"f"\fP.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRRPadPressGrid3x3_7\fP: The logical \fBbutton\fP on the \fBright\fP trackpad corresponding to \fBfig. 4\fP, region \fB"g"\fP.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRRPadPressGrid3x3_8\fP: The logical \fBbutton\fP on the \fBright\fP trackpad corresponding to \fBfig. 4\fP, region \fB"h"\fP.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
\f(CRRPadPressGrid3x3_9\fP: The logical \fBbutton\fP on the \fBright\fP trackpad corresponding to \fBfig. 4\fP, region \fB"i"\fP.
.RE
.sp
.ce
\l'\n(.lu*25u/100u\(ap'
.bp
.SS "Example config.ini"
.sp
.if n .RS 4
.nf
.fam C
[Daemon]
# The gamepad profile to be loaded on startup
Profile = default.profile

# Allow client connections from CLI and GUI configuration tools
AllowClients = true
.fam
.fi
.if n .RE
.sp
.ce
\l'\n(.lu*25u/100u\(ap'
.bp
.SS "Example Profile"
.sp
.if n .RS 4
.nf
.fam C
[Profile]
Name            = Example Profile
Description     = Just an example profile to show basic use

[Features]
ForceFeedback      = true
MotionDevice       = true
MouseDevice        = true
LizardMode         = false
StickFiltering     = true
TrackpadFiltering  = true

[Deadzones]
LStick    = 0.1
RStick    = 0.1
LPad      = 0
RPad      = 0
LTrigg    = 0
RTrigg    = 0

[GamepadAxes]
ABS_HAT0X    = \-1        1
ABS_HAT0Y    = \-1        1
ABS_X        = \-32767    32767
ABS_Y        = \-32767    32767
ABS_RX       = \-32767    32767
ABS_RY       = \-32767    32767
ABS_Z        = 0         32767
ABS_RZ       = 0         32767

[MotionAxes]
ABS_X        = \-32767    32767
ABS_Y        = \-32767    32767
ABS_Z        = \-32767    32767
ABS_RX       = \-32767    32767
ABS_RY       = \-32767    32767
ABS_RZ       = \-32767    32767

[Bindings]
DpadUp              = Gamepad   ABS_HAT0Y   \-
DpadDown            = Gamepad   ABS_HAT0Y   +
DpadLeft            = Gamepad   ABS_HAT0X   \-
DpadRight           = Gamepad   ABS_HAT0X   +
# Buttons
A                   = Gamepad   BTN_SOUTH
B                   = Gamepad   BTN_EAST
X                   = Gamepad   BTN_WEST
Y                   = Gamepad   BTN_NORTH
L1                  = Gamepad   BTN_TL
R1                  = Gamepad   BTN_TR
L2                  = Gamepad   BTN_TL2
R2                  = Gamepad   BTN_TR2
L3                  = Gamepad   BTN_THUMBL
R3                  = Gamepad   BTN_THUMBR
L4                  = None
R4                  = None
L5                  = None
R5                  = None
Menu                = Gamepad   BTN_START
Options             = Gamepad   BTN_SELECT
Steam               = Gamepad   BTN_MODE
QuickAccess         = Command   true        0   rofi \-show drun
# Triggers
LTrigg              = Gamepad   ABS_Z       +
RTrigg              = Gamepad   ABS_RZ      +
# Left Stick
LStickUp            = Gamepad   ABS_Y       \-
LStickDown          = Gamepad   ABS_Y       +
LStickLeft          = Gamepad   ABS_X       \-
LStickRight         = Gamepad   ABS_X       +
LStickTouch         = None
LStickForce         = None
# Right Stick
RStickUp            = Gamepad   ABS_RY      \-
RStickDown          = Gamepad   ABS_RY      +
RStickLeft          = Gamepad   ABS_RX      \-
RStickRight         = Gamepad   ABS_RX      +
RStickTouch         = None
RStickForce         = None
# Left Trackpad
LPadUp              = None
LPadDown            = None
LPadLeft            = None
LPadRight           = None
LPadRelX            = None
LPadRelY            = None
LPadTouch           = None
LPadPress           = Mouse     BTN_LEFT
LPadForce           = None
LPadPressQuadUp     = None
LPadPressQuadDown   = None
LPadPressQuadLeft   = None
LPadPressQuadRight  = None
LPadPressOrthUp     = None
LPadPressOrthDown   = None
LPadPressOrthLeft   = None
LPadPressOrthRight  = None
LPadPressGrid2x2_1  = None
LPadPressGrid2x2_2  = None
LPadPressGrid2x2_3  = None
LPadPressGrid2x2_4  = None
LPadPressGrid3x3_1  = None
LPadPressGrid3x3_2  = None
LPadPressGrid3x3_3  = None
LPadPressGrid3x3_4  = None
LPadPressGrid3x3_5  = None
LPadPressGrid3x3_6  = None
LPadPressGrid3x3_7  = None
LPadPressGrid3x3_8  = None
LPadPressGrid3x3_9  = None
# Right Trackpad
RPadUp              = None
RPadDown            = None
RPadLeft            = None
RPadRight           = None
RPadRelX            = Mouse     REL_X
RPadRelY            = Mouse     REL_Y
RPadTouch           = None
RPadPress           = Mouse     BTN_RIGHT
RPadForce           = None
RPadPressQuadUp     = None
RPadPressQuadDown   = None
RPadPressQuadLeft   = None
RPadPressQuadRight  = None
RPadPressOrthUp     = None
RPadPressOrthDown   = None
RPadPressOrthLeft   = None
RPadPressOrthRight  = None
RPadPressGrid2x2_1  = None
RPadPressGrid2x2_2  = None
RPadPressGrid2x2_3  = None
RPadPressGrid2x2_4  = None
RPadPressGrid3x3_1  = None
RPadPressGrid3x3_2  = None
RPadPressGrid3x3_3  = None
RPadPressGrid3x3_4  = None
RPadPressGrid3x3_5  = None
RPadPressGrid3x3_6  = None
RPadPressGrid3x3_7  = None
RPadPressGrid3x3_8  = None
RPadPressGrid3x3_9  = None
# Accelerometers
AccelXPlus          = Motion    ABS_RX      +
AccelXMinus         = Motion    ABS_RX      \-
AccelYPlus          = Motion    ABS_RY      +
AccelYMinus         = Motion    ABS_RY      \-
AccelZPlus          = Motion    ABS_RZ      +
AccelZMinus         = Motion    ABS_RZ      \-
# Gyro / Attitude
RollPlus            = Motion    ABS_X       +
RollMinus           = Motion    ABS_X       \-
PitchPlus           = Motion    ABS_Y       +
PitchMinus          = Motion    ABS_Y       \-
YawPlus             = Motion    ABS_Z       +
YawMinus            = Motion    ABS_Z       \-
.fam
.fi
.if n .RE
.SS "Troubleshooting"
.sp
TODO:
.SH "AUTHOR"
.sp
seek